<style> 
body {
;	margin				: 0px
;	display				: grid
;	grid-template-rows	: 1fr auto
}
main {
;	overflow			: scroll
}
footer {
;	color				: white
}
</style> 

<main id=MAIN>
	<canvas id=CANVAS></canvas>
</main>
<footer>
	<label style="margin-left: 16px">Iterations</label><input id="ITERATIONS" type="range" min="2" max="1000" value="100" step="1" >
	<input id=REDRAW type=button value=Redraw>
</footer>

<script>

let iterations	= Number( ITERATIONS.value )

let	rMin		= -2
let	rMax		= 1
let	iMin		= -1
let	iMax		= 1

CANVAS.onmousedown = md => {
	const _rMin = rMin
	const _rMax = rMax
	const _iMin = iMin
	const _iMax = iMax
	const bR = ( rMax - rMin ) / CANVAS.width
	const bI = ( iMax - iMin ) / CANVAS.height
	CANVAS.onmousemove	= _ => {
		const dX = _.clientX - md.clientX
		const dY = _.clientY - md.clientY
		if ( dX ) {
			const _ = bR * dX
			rMin = _rMin - _
			rMax = _rMax - _
		}
		if ( dY ) {
			const _ = bI * dY
			iMin = _iMin + _
			iMax = _iMax + _
		}
		Draw()
	}
	CANVAS.onmouseleave = _ => CANVAS.onmousemove = CANVAS.onmouseleave = CANVAS.onmouseup = null
	CANVAS.onmouseup		= _ => {
		CANVAS.onmouseleave()
		if ( _.clientX === md.clientX && _.clientY === md.clientY ) {

			const r = rMin + bR * _.clientX;
			const rRange = ( rMax - rMin ) / 2;
			const bR2 = bR / 2;
			rMin = r - bR2 * _.clientX;
			rMax = rMin + rRange;

			const i = iMin + bI * ( CANVAS.height - 1 - _.clientY );
			const iRange = ( iMax - iMin ) / 2;
			const bI2 = bI / 2;
			iMin = i - bI2 * _.clientY;
			iMax = iMin + iRange;

			Draw();
		}
	}
}

// WebGL

const gl = CANVAS.getContext( 'webgl2' )

const buffer = gl.createBuffer();
gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
gl.bufferData(
	gl.ARRAY_BUFFER
,	new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] )
,	gl.STATIC_DRAW
)

const
program = gl.createProgram()

const
Shader = ( src, type ) => {
	var $ = gl.createShader( type )
	gl.shaderSource( $, src )
	gl.compileShader( $ )
	if ( !gl.getShaderParameter( $, gl.COMPILE_STATUS ) ) throw gl.getShaderInfoLog( $ )
	gl.attachShader( program, $ )
	gl.deleteShader( $ )
}

Shader(
	`
		attribute vec3 position;
		void
		main() {
			gl_Position = vec4( position, 1.0 );
		}
	`
,	gl.VERTEX_SHADER
)

Shader(
	`
		precision highp float;
		precision highp int;

		uniform vec2	min;
		uniform vec2	max;

		uniform vec2	resolution;
		uniform int		iterations;

		vec4
		RGB_HUE( float _ ) {						// 0 <= _ < 1
			int		i = int( floor( _ * 6.0 ) );	// 0, 1, 2, 3, 4, 5
			float	p = _ - float( i );				// 0 <= p <= 1
			float	q = 1.0 - p;					// 1 >= q >= 0
			if ( i == 0 ) return vec4( 1.0, p, 0, 1.0 );
			if ( i == 1 ) return vec4( q, 1.0, 0, 1.0 );
			if ( i == 2 ) return vec4( 0, 1.0, p, 1.0 );
			if ( i == 3 ) return vec4( 0, q, 1.0, 1.0 );
			if ( i == 4 ) return vec4( p, 0, 1.0, 1.0 );
			if ( i == 5 ) return vec4( 1.0, 0, q, 1.0 );
		}

		int
		Mandelbrot( vec2 c ) {
			vec2 z = c;
			for( int i = 1; i < 1000; ++i ) {
				if ( i >= iterations ) break;

				vec2 z2 = z * z;
				if ( z2.x + z2.y > 4.0 ) return i;
				
				z = vec2(
					( z2.x - z2.y )
				,	( z.y * z.x * 2.0 )
				) + c; 
			//	TODO: COMPARE ELAPPSED
			//	z.y = ( z.y * z.x * 2.0 ) + c.y; 
			//	z.x = ( z2.x - z2.y ) + c.x; 
			}
			return 0;
		}

		void
		main( void ) {
			int i = Mandelbrot(
				vec2(
					min.x + ( max.x - min.x ) * gl_FragCoord.x / resolution.x
				,	min.y + ( max.y - min.y ) * gl_FragCoord.y / resolution.y
				)
			);
			gl_FragColor = i == 0
			?	vec4( 0.0, 0.0, 0.0, 1.0 )
			:	RGB_HUE( float( i ) / float( iterations ) )
		//	:	vec4( 0.6, 0.8, 1.0, 0.0 ) * float( i ) / float( iterations ) + vec4( 0.0, 0.2, 0.4, 1.0 )
			;
		}
	`
,	gl.FRAGMENT_SHADER
)

gl.linkProgram( program )

if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) throw gl.getError()

const minLocation			= gl.getUniformLocation( program, 'min'			)
const maxLocation			= gl.getUniformLocation( program, 'max'			)
const resolutionLocation	= gl.getUniformLocation( program, 'resolution'	)
const iterationLocation		= gl.getUniformLocation( program, 'iterations'	)

const
Draw = () => {

	gl.viewport( 0, 0, CANVAS.width, CANVAS.height )

	gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT )

	gl.useProgram( program )

	gl.uniform2f( minLocation			, rMin, iMin )
	gl.uniform2f( maxLocation			, rMax, iMax )
	gl.uniform2f( resolutionLocation	, CANVAS.width, CANVAS.height )
	gl.uniform1i( iterationLocation		, iterations )

	let
	vertex_position

	gl.bindBuffer				( gl.ARRAY_BUFFER, buffer )
	gl.vertexAttribPointer		( vertex_position, 2, gl.FLOAT, false, 0, 0 )
	gl.enableVertexAttribArray	( vertex_position )
	gl.drawArrays				( gl.TRIANGLES, 0, 6 )
	gl.disableVertexAttribArray	( vertex_position )
}

const
Redraw = () => (
	CANVAS.width	= MAIN.clientWidth
,	CANVAS.height	= MAIN.clientHeight
,	Draw()
)

ITERATIONS.oninput = () => (
	iterations = Number( ITERATIONS.value )
,	Draw()
)

REDRAW.onclick = Redraw

onload = Redraw

/*
const
animate = () => (
	SyncDraw()
,	requestAnimationFrame( animate )
)
animate()
*/
</script> 

