2
-3
2-3
2--3

2+3
2-3
2×3
2÷3
2+3×4
(2+3)×4
2×3+4
2×(3+4)
6÷2×3

sqrt(4)
cbrt(8)

π
sin(0)
sinπ
cos(0)
cosπ
tan(0)
tanπ


e
exp(0)
// expected output: 1
exp(1)
// expected output: 2.718281828459 (approximately)
exp(-1)
// expected output: 0.36787944117144233
exp(2)
// expected output: 7.38905609893065

log( e )
log( e × e )

'log10 = '( log( @ ) ÷ log( 10 ) )
100:log10

"-------------------------------- Matrix"
[ 1 2 3 ] · [ 1 2 3 ]
[ [ 1 2 3 4 5 6 ] 3 ] : matrix
[ [ 1 2 3 4 5 6 ] 2 ] : matrix · [ [ 1 2 3 4 5 6 ] 3 ]: matrix

"-------------------------------- String"

""
"ABC"
"A\tB\"C\nD"
"ABC" + "DEF"

"-------------------------------- String <-> Integer"

[ 65536 16 ] : string
[ "10000" 16 ] : int

"-------------------------------- Memory"

'a = 1 + 2
'b = 3 + 4
a + b


"-------------------------------- Logical"
//	"T" for true, Nil i.e. '[ ]' for false.

3 == 3
3 == 4

"A" == "A"

"A" == "B"


"-------------------------------- If else"

3 == 3 ? [ "TRUE" "FALSE" ]
3 == 4 ? [ "TRUE" "FALSE" ]

"-------------------------------- List"
[ a b ]
'[ a b ]
'( a b )
'{ a b }
[ a b c ]:#


"-------------------------------- Primitives"
"---------------- Stack Top"
3:'(@)
3:'@
//	3:@ =	//	Stack underflow

3:'(@==3)

'{}:'(@==[])
'{}:'(@=={})

"-------------------------------- Function"

'add1 = '( @ + 1 )
3 : add1
//	'3 : add1' means push 3 to stack and evaluate function associated with name 'add1'.
//	@ is stack top.

'factorial = '( @ == 1 ? [ 1 ( @ × ( @ - 1 ):factorial ) ] )
4 : factorial

'sigma = '( @ == 0 ? [ 0 ( @ + ( @ - 1 ):sigma ) ] )
4 : sigma

"-------------------------------- List"

[ "A" "B" "C" ] + [ "D" "E" "F" ]
//	Lisp's CAR
[ "A" "B" "C" ]:0
[ "A" "B" "C" ]:1
[ "A" "B" "C" ]:$
[ "A" "B" "C" ]:#
//	Lisp's CDR
[ "A" "B" "C" ]:*

//	Lisp's CONS
"A", [ "B" "C" ]

"-------------------------------- Members"

"A" ∈ [ "A" "B" "C" ]
"D" ∈ [ "A" "B" "C" ]
[ "A" "B" "C" ] ∋ "A"
[ "A" "B" "C" ] ∋ "D"

"-------------------------------- Builtins"
"Show all"
¤
