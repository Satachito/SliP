//	SliP ver 1.0(Swift) 2016 written by Satoru Ogura, Tokyo.
//	This is sample script for SliP, please push 'CALCULATE' button.

//	Four arithmetic operations
//	Please insert spaces between operator and number.

1 + 2;
1 + 2 × 3;
( 1 + 2 ) × 3;
5 - 3;
5 ÷ 3;
5 / 3;
5 % 3;


//	Builtin functions and constants

0 : cos;
( M_PI ÷ 3 ) : cos;
		//	Show all
· : ¦;


//	Bitwise operations

2 | 3;
2 & 3;
2 ^ 3;


//	Memory

'a = 1 + 2;
'b = 3 + 4;
a + b;


//	Logical
//	"T" for true, Nil i.e. '[ ]' for false.

3 == 3;
3 == 4;


//	String

"ABC" + "DEF";


//	If else

3 == 3 ? [ "TRUE" "FALSE" ];
3 == 4 ? [ "TRUE" "FALSE" ];


//	Function

'add1 = '( @ + 1 );
3 : add1;
//	'3 : add1' means push 3 to stack and evaluate function associated with name 'add1'.
//	@ is stack top.

'factorial = '(
	@ × ( @ == 1 ? [ 1 ( ( @ - 1 ):factorial ) ] )
);
4 : factorial;

'sigma = '(
	@ + ( @ == 0 ? [ 0 ( ( @ - 1 ):sigma ) ] )
);
4 : sigma;

'fibonacci = '(
	@ < 2 ? [
		@
		( ( @ - 1 ):fibonacci + ( @ - 2 ):fibonacci )
	]
);
10:fibonacci;


//	List

[ "A" "B" "C" ] + [ "D" "E" "F" ];
[ "A" "B" "C" ]:0;	//	Lisp's CAR
[ "A" "B" "C" ]:1;
[ "A" "B" "C" ]:$;
[ "A" "B" "C" ]:#;
[ "A" "B" "C" ]:*;	//	Lisp's CDR

"A", [ "B" "C" ];	//	Lisp's CONS

//	Procedure
{	( 'a = 1 + 2 )
	( 'b = 3 + 4 )
	( a + b )
};

//	Function 2

'gcd = '(
	@:1 == 0 ? [
		( @:0 )
		( { ( @:1 ) ( @:0 % @:1 ) }:gcd )
	]
);
[ 1071 1029 ]:gcd;

'reduce = '(
	@:0:# == 1 ? [
		(@:0:0)
		( { (@:0:0) ( { (@:0:*) (@:1) }:reduce ) }:(@:1) )
	]
);
[ [ 1 2 3 4 ]( @:0 + @:1 ) ]:reduce;
[ [ 1 2 3 4 ]( @:0 × @:1 ) ]:reduce;

//	Print

"This string goes to lower right text view.\n" : ¦;
"This string also goes to lower right text view.\n" : ¦;


//	Parallel evaluation

«
	( { ( 'a = 3 ) a }:$ )
	( { ( 'a = 4 ) a }:$ )
	( { ( 'a = 5 ) a }:$ )
»;


//	Members

"A" ∈ [ "A" "B" "C" ];
"D" ∈ [ "A" "B" "C" ];
[ "A" "B" "C" ] ∋ "A";
[ "A" "B" "C" ] ∋ "D";


//	Comprehensive

'hanoi = '{
	( 'n	= @:0 )
	( 'from	= @:1 )
	( 'to	= @:2 )
	( 'via	= @:3 )
	( n == 1 ? [
		{ ("From ":¦) (from:¦) (" To ":¦) (to:¦) ("\n":¦) }
		{	( { ( n - 1 ) from via to }:hanoi )
			{ ("From ":¦) (from:¦) (" To ":¦) (to:¦) ("\n":¦) }
			( { ( n - 1 ) via to from }:hanoi )
		}
	] )
};
[ 3 a b c ]:hanoi;


